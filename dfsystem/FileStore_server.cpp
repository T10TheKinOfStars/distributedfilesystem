// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "FileStore.h"
#include "fileworker.h"
#include "DHTController.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/PosixThreadFactory.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace ::apache::thrift::concurrency;

using boost::shared_ptr;

FileWorker fworker;
class FileStoreHandler : virtual public FileStoreIf {
 private:
    DHTController dhtcntler;
 public:
  FileStoreHandler(int port) {
    // Your initialization goes here
    dhtcntler.setPort(port);
  }

  void writeFile(const RFile& rFile) {
    // Your implementation goes here
    fworker.writefile(rFile);
  }

  void readFile(RFile& _return, const std::string& filename, const UserID& owner) {
    // Your implementation goes here
    if (fworker.getUserFileMap().find(owner) != fworker.getUserFileMap().end()) {
        if (fworker.readfile(owner,filename,_return) == -1) {
            SystemException se;
            se.__set_message("read file failed");
            throw se;
        }
    }
  }

  void deleteFile(const std::string& filename, const UserID& owner) {
    // Your implementation goes here
    if (fworker.getUserFileMap().find(owner) != fworker.getUserFileMap().end())
        fworker.deletefile(owner,filename); 
  }

  void setFingertable(const std::vector<NodeID> & node_list) {
    // Your implementation goes here
    dprintf("setFingertable\n");
    dhtcntler.setFingerTB(node_list); 
    dhtcntler.setInitFlag();
  }

  void updateFinger(const int32_t idx, const NodeID& nodeId) {
    // Your implementation goes here
    dprintf("updateFinger\n");
    if (!dhtcntler.checkFtbInit()) {
        SystemException se;
        se.__set_message("finger table uninitialized\n");
        throw se;
    }
    dhtcntler.updateFingertb(idx,nodeId);
  }

  void getFingertable(std::vector<NodeID> & _return) {
    // Your implementation goes here
    dprintf("getFingertable\n");
    if (!dhtcntler.checkFtbInit()) {
        SystemException se;
        se.__set_message("finger table uninitialized\n");
        throw se;
    }
    _return = dhtcntler.getFingertb();
  }

  void fixFingers() {
    // Your implementation goes here
    printf("fixFingers\n");
  }

  void findSucc(NodeID& _return, const std::string& key) {
    // Your implementation goes here
    dprintf("findSucc\n");
    if (!dhtcntler.checkFtbInit()) {
        SystemException se;
        se.__set_message("finger table uninitialized\n");
        throw se;
    }
    //先找这个key的前驱x，再找x的后继
    NodeID predecessor = dhtcntler.findPred(key);
    _return = dhtcntler.RPCGetNodeSucc(predecessor);
  }

  void findPred(NodeID& _return, const std::string& key) {
    // Your implementation goes here
    dprintf("findPred\n");
    if (!dhtcntler.checkFtbInit()) {
        SystemException se;
        se.__set_message("finger table uninitialized\n");
        throw se;
    }
    _return = dhtcntler.findPred(key);
  }

  void getNodeSucc(NodeID& _return) {
    // Your implementation goes here
    dprintf("getNodeSucc\n");
    if (!dhtcntler.checkFtbInit()) {
        SystemException se;
        se.__set_message("finger table uninitialized\n");
        throw se;
    }
    _return = dhtcntler.getSucc();
  }

  void getNodePred(NodeID& _return) {
    // Your implementation goes here
    dprintf("getNodePred\n");
    if (!dhtcntler.checkFtbInit()) {
        SystemException se;
        se.__set_message("finger table uninitialized\n");
        throw se;
    }
    _return = dhtcntler.getPred();
  }

  void setNodePred(const NodeID& nodeId) {
    // Your implementation goes here
    dprintf("setNodePred\n");
    if (!dhtcntler.checkFtbInit()) {
        SystemException se;
        se.__set_message("finger table uninitialized\n");
        throw se;
    }
    dhtcntler.setPred(nodeId);
  }

  void pullUnownedFiles(std::vector<RFile> & _return) {
    // Your implementation goes here
    printf("pullUnownedFiles\n");
  }

  void pushUnownedFiles(const std::vector<RFile> & files) {
    // Your implementation goes here
    printf("pushUnownedFiles\n");
  }

  void join(const NodeID& nodeId) {
    // Your implementation goes here
    printf("join\n");
  }

  void remove() {
    // Your implementation goes here
    printf("remove\n");
  }

  void stabilize() {
    // Your implementation goes here
    printf("stabilize\n");
  }

  void notify(const NodeID& nodeId) {
    // Your implementation goes here
    printf("notify\n");
  }

};

int main(int argc, char **argv) {
  if (argc < 2) {
    std::cout<<"should run like ./server 9090\n";
    exit(1);
  }
  int port = atoi(argv[1]);
  const int workerCount = 4;

  shared_ptr<FileStoreHandler> handler(new FileStoreHandler(port));
  shared_ptr<TProcessor> processor(new FileStoreProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  boost::shared_ptr<ThreadManager> threadManager =
    ThreadManager::newSimpleThreadManager(workerCount);
  boost::shared_ptr<PosixThreadFactory> threadFactory =
    boost::shared_ptr<PosixThreadFactory>(new PosixThreadFactory());
  threadManager->threadFactory(threadFactory);
  threadManager->start();

  TThreadedServer server(processor, serverTransport, transportFactory, protocolFactory);

  fworker.initFolder(port);
  server.serve();
  return 0;
}

