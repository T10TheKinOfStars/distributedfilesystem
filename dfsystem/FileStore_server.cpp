// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "FileStore.h"
#include "fileworker.h"
#include "DHTController.h"
#include "network.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/PosixThreadFactory.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace ::apache::thrift::concurrency;

using boost::shared_ptr;

FileWorker fworker;
class FileStoreHandler : virtual public FileStoreIf {
 private:
    DHTController dhtcntler;
 public:
  FileStoreHandler(std::string ip, int port) {
    // Your initialization goes here
    dhtcntler.setCur(ip, port);
  }

  void writeFile(const RFile& rFile) {
    // Your implementation goes here
    fworker.writefile(rFile, dhtcntler.getCur().port);
  }

  void readFile(RFile& _return, const std::string& filename, const UserID& owner) {
    // Your implementation goes here
    if (fworker.getUserFileMap().find(owner) != fworker.getUserFileMap().end()) {
        if (fworker.readfile(dhtcntler.getCur().port, owner,filename,_return) == -1) {
            SystemException se;
            se.__set_message("read file failed");
            throw se;
        }
    }
  }

  void deleteFile(const std::string& filename, const UserID& owner) {
    // Your implementation goes here
    if (fworker.getUserFileMap().find(owner) != fworker.getUserFileMap().end())
        fworker.deletefile(dhtcntler.getCur().port, owner,filename); 
  }

  void setFingertable(const std::vector<NodeID> & node_list) {
    // Your implementation goes here
    dprintf("setFingertable\n");
    dhtcntler.setFingerTB(node_list); 
    dhtcntler.setInitFlag();
  }

  void updateFinger(const int32_t idx, const NodeID& nodeId) {
    // Your implementation goes here
    dprintf("updateFinger\n");
    if (!dhtcntler.checkFtbInit()) {
        SystemException se;
        se.__set_message("finger table uninitialized\n");
        throw se;
    }
    dhtcntler.updateFingertb(idx,nodeId);
  }

  void getFingertable(std::vector<NodeID> & _return) {
    // Your implementation goes here
    dprintf("getFingertable\n");
    if (!dhtcntler.checkFtbInit()) {
        SystemException se;
        se.__set_message("finger table uninitialized\n");
        throw se;
    }
    _return = dhtcntler.getFingertb();
  }

  void fixFingers() {
    // Your implementation goes here
    printf("fixFingers\n");
  }

  void findSucc(NodeID& _return, const std::string& key) {
    // Your implementation goes here
    //dprintf("findSucc\n");
    if (!dhtcntler.checkFtbInit()) {
        SystemException se;
        se.__set_message("finger table uninitialized\n");
        throw se;
    }
    if (key == dhtcntler.getCur().id) { 
        _return = dhtcntler.getCur();
    } else {
        //先找这个key的前驱x，再找x的后继
        NodeID pre = dhtcntler.findPred(key);
        dprintf("The pre for %s is %s:%d\n",key.c_str(),pre.ip.c_str(),pre.port);
        _return = dhtcntler.RPCGetNodeSucc(pre);
    }
  }

  void findPred(NodeID& _return, const std::string& key) {
    // Your implementation goes here
    //dprintf("findPred\n");
    if (!dhtcntler.checkFtbInit()) {
        SystemException se;
        se.__set_message("finger table uninitialized\n");
        throw se;
    }
    _return = dhtcntler.findPred(key);
  }

  void getNodeSucc(NodeID& _return) {
    // Your implementation goes here
    dprintf("getNodeSucc\n");
    if (!dhtcntler.checkFtbInit()) {
        SystemException se;
        se.__set_message("finger table uninitialized\n");
        throw se;
    }
    dprintf("The cur node is %s:%d\n",dhtcntler.getCur().ip.c_str(),dhtcntler.getCur().port);
    _return = dhtcntler.getSucc();
  }

  void getNodePred(NodeID& _return) {
    // Your implementation goes here
    dprintf("getNodePred\n");
    if (!dhtcntler.checkFtbInit()) {
        SystemException se;
        se.__set_message("finger table uninitialized\n");
        throw se;
    }
    _return = dhtcntler.getPred();
  }

  void setNodePred(const NodeID& nodeId) {
    // Your implementation goes here
    dprintf("setNodePred\n");
    if (!dhtcntler.checkFtbInit()) {
        SystemException se;
        se.__set_message("finger table uninitialized\n");
        throw se;
    }
    dhtcntler.setPred(nodeId);
  }

  void pullUnownedFiles(std::vector<RFile> & _return) {
    // Your implementation goes here
    printf("pullUnownedFiles\n");
  }

  void pushUnownedFiles(const std::vector<RFile> & files) {
    // Your implementation goes here
    printf("pushUnownedFiles\n");
  }

  void join(const NodeID& nodeId) {
    // Your implementation goes here
    printf("join\n");
  }

  void remove() {
    // Your implementation goes here
    printf("remove\n");
  }

  void stabilize() {
    // Your implementation goes here
    printf("stabilize\n");
  }

  void notify(const NodeID& nodeId) {
    // Your implementation goes here
    printf("notify\n");
  }

};

int main(int argc, char **argv) {
  if (argc < 2) {
    std::cout<<"should run like ./server 9090\n";
    exit(1);
  }
  std::string ip = get_local_ip();
  int port = atoi(argv[1]);
  const int workerCount = 4;

  shared_ptr<FileStoreHandler> handler(new FileStoreHandler(ip,port));
  shared_ptr<TProcessor> processor(new FileStoreProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  boost::shared_ptr<ThreadManager> threadManager =
    ThreadManager::newSimpleThreadManager(workerCount);
  boost::shared_ptr<PosixThreadFactory> threadFactory =
    boost::shared_ptr<PosixThreadFactory>(new PosixThreadFactory());
  threadManager->threadFactory(threadFactory);
  threadManager->start();

  TThreadedServer server(processor, serverTransport, transportFactory, protocolFactory);

  fworker.initFolder(port);
  server.serve();
  return 0;
}

