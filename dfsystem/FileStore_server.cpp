// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "FileStore.h"
#include "fileworker.h"
#include "DHTController.h"
#include "network.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/PosixThreadFactory.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace ::apache::thrift::concurrency;

using boost::shared_ptr;

FileWorker fworker;
class FileStoreHandler : virtual public FileStoreIf {
 private:
    DHTController dhtcntler;
 public:
  FileStoreHandler(std::string ip, int port) {
    // Your initialization goes here
    dhtcntler.setCur(ip, port);
  }

  void writeFile(const RFile& rFile) {
    // Your implementation goes here
    fworker.writefile(rFile, dhtcntler.getCur().port);
  }

  void readFile(RFile& _return, const std::string& filename, const UserID& owner) {
    // Your implementation goes here
    if (fworker.getUserFileMap().find(owner) != fworker.getUserFileMap().end()) {
        if (fworker.readfile(dhtcntler.getCur().port, owner,filename,_return) == -1) {
            SystemException se;
            se.__set_message("read file failed");
            throw se;
        }
    }
  }

  void deleteFile(const std::string& filename, const UserID& owner) {
    // Your implementation goes here
    if (fworker.getUserFileMap().find(owner) != fworker.getUserFileMap().end())
        fworker.deletefile(dhtcntler.getCur().port, owner,filename); 
  }

  void setFingertable(const std::vector<NodeID> & node_list) {
    // Your implementation goes here
    dprintf("setFingertable\n");
    dhtcntler.setFingerTB(node_list); 
    dhtcntler.setInitFlag();
  }

  void updateFinger(const int32_t idx, const NodeID& nodeId) {
    // Your implementation goes here
    dprintf("updateFinger\n");
    if (!dhtcntler.checkFtbInit()) {
        SystemException se;
        se.__set_message("finger table uninitialized\n");
        throw se;
    }
    dhtcntler.updateFingertb(idx,nodeId);
  }

  void getFingertable(std::vector<NodeID> & _return) {
    // Your implementation goes here
    dprintf("getFingertable\n");
    if (!dhtcntler.checkFtbInit()) {
        SystemException se;
        se.__set_message("finger table uninitialized\n");
        throw se;
    }
    _return = dhtcntler.getFingertb();
  }

  void fixFingers() {
    // Your implementation goes here
    dprintf("fixFingers\n");
    dhtcntler.fixFingertb();
  }

  void findSucc(NodeID& _return, const std::string& key) {
    // Your implementation goes here
    //dprintf("findSucc\n");
    if (!dhtcntler.checkFtbInit()) {
        SystemException se;
        se.__set_message("finger table uninitialized\n");
        throw se;
    }
    if (key == dhtcntler.getCur().id) { 
        _return = dhtcntler.getCur();
    } else {
        //先找这个key的前驱x，再找x的后继
        NodeID pre = dhtcntler.findPred3(key);
        dprintf("The pre for %s is %s:%d\n",key.c_str(),pre.ip.c_str(),pre.port);
        _return = dhtcntler.RPCGetNodeSucc(pre);
    }
  }

  void findPred(NodeID& _return, const std::string& key) {
    // Your implementation goes here
    dprintf("findPred\n");
    if (!dhtcntler.checkFtbInit()) {
        SystemException se;
        se.__set_message("finger table uninitialized\n");
        throw se;
    }
    {
        _return = dhtcntler.findPred3(key);
    }
    {
        //_return = dhtcntler.findPred4(key);
    }
  }

  void getNodeSucc(NodeID& _return) {
    // Your implementation goes here
    dprintf("getNodeSucc\n");
    if (!dhtcntler.checkFtbInit()) {
        SystemException se;
        se.__set_message("finger table uninitialized\n");
        throw se;
    }
    dprintf("The cur node is %s:%d\n",dhtcntler.getCur().ip.c_str(),dhtcntler.getCur().port);
    _return = dhtcntler.getSucc();
  }

  void getNodePred(NodeID& _return) {
    // Your implementation goes here
    dprintf("getNodePred\n");
    if (!dhtcntler.checkFtbInit()) {
        SystemException se;
        se.__set_message("finger table uninitialized\n");
        throw se;
    }
    _return = dhtcntler.getPred();
  }

  void setNodePred(const NodeID& nodeId) {
    // Your implementation goes here
    dprintf("setNodePred\n");
    if (!dhtcntler.checkFtbInit()) {
        SystemException se;
        se.__set_message("finger table uninitialized\n");
        throw se;
    }
    dhtcntler.setPred(nodeId);
  }

  void pullUnownedFiles(std::vector<RFile> & _return) {
    // Your implementation goes here
    dprintf("pullUnownedFiles\n");
    std::vector<RFileMetadata> metadatas;
    fworker.getAllFiles(metadatas);
    NodeID cur = dhtcntler.getCur(); 
    for (int i = 0; i < (int)metadatas.size(); ++i) {
        RFile tmp;
        int ret = fworker.readfile(cur.port, metadatas[i].owner, metadatas[i].filename, tmp);
        if (ret == -1)
            dprintf("readfile failed in pull\n");
        else
            _return.push_back(tmp);
    }
  }

  void pushUnownedFiles(const std::vector<RFile> & files) {
    // Your implementation goes here
    dprintf("pushUnownedFiles\n");
    NodeID cur = dhtcntler.getCur(); 
    for (auto rfile : files) {
        int ret = fworker.writefile(rfile,cur.port);
        if (ret < 0) {
            SystemException se;
            se.__set_message("writefile failed in push\n");
            throw se;
        }
    }
  }

  void join(const NodeID& nodeId) {
    // Your implementation goes here
    dprintf("join\n");
    {
        //stage 3
        std::vector<RFile> migratefiles;
        dhtcntler.join3(nodeId);
        NodeID succ = dhtcntler.getSucc();
        boost::shared_ptr<FileStoreClient> client(dhtcntler.getClientConn(succ.ip, succ.port));
        client->pullUnownedFiles(migratefiles); 
        pushUnownedFiles(migratefiles);
    }
    {
        //stage 4
        //dhtcntler.join4(nodeId);
    }
  }

  void remove() {
    // Your implementation goes here
    dprintf("remove\n");
    std::vector<RFile> migratefiles;

    NodeID succ = dhtcntler.getSucc();
    NodeID curr = dhtcntler.getCur();
    if (succ == curr) {
        //only one node in network
        //so if we remove it, all files should be deleted
        fworker.removefiles(curr.port);
        return;
    }

    std::vector<RFileMetadata> files;
    if (fworker.getAllFiles(files) > 0) {
        for (int i = 0; i < (int)files.size(); ++i) {
            RFile tmp;
            int ret = fworker.readfile(curr.port, files[i].owner, files[i].filename, tmp);
            if (ret == -1) {
                dprintf("readfile failed %d %s %s\n", curr.port, files[i].owner.c_str(), files[i].filename.c_str());
            } else {
                migratefiles.push_back(tmp);
            }
        }
    } else {
        //if less or equal than 0, means no files in network, no more action
        return;
    }

    boost::shared_ptr<FileStoreClient> client(dhtcntler.getClientConn(succ.ip, succ.port));
    client->pushUnownedFiles(migratefiles);
    fworker.removefiles(curr.port);
  }

  void stabilize() {
    // Your implementation goes here
    dprintf("stabilize\n");
    dhtcntler.stabilize();
  }

  void notify(const NodeID& nodeId) {
    // Your implementation goes here
    dprintf("notify\n");
    dhtcntler.notify(nodeId);
  }

};

int main(int argc, char **argv) {
  if (argc < 2) {
    std::cout<<"should run like ./server 9090\n";
    exit(1);
  }
  std::string ip = get_local_ip();
  int port = atoi(argv[1]);
  const int workerCount = 4;

  shared_ptr<FileStoreHandler> handler(new FileStoreHandler(ip,port));
  shared_ptr<TProcessor> processor(new FileStoreProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  boost::shared_ptr<ThreadManager> threadManager =
    ThreadManager::newSimpleThreadManager(workerCount);
  boost::shared_ptr<PosixThreadFactory> threadFactory =
    boost::shared_ptr<PosixThreadFactory>(new PosixThreadFactory());
  threadManager->threadFactory(threadFactory);
  threadManager->start();

  TThreadedServer server(processor, serverTransport, transportFactory, protocolFactory);

  fworker.initFolder(port);
  server.serve();
  return 0;
}

